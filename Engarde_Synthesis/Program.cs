using System;
using System.Collections.Generic;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Threading.Tasks;
using Engarde_Synthesis.Settings;
using Noggog;


//TODO: delete this
#pragma warning disable CA1416
namespace Engarde_Synthesis
{
    public class Program
    {
        #region Statics

        private static readonly ModKey Engarde = ModKey.FromNameAndExtension("Engarde.esp");
        private static readonly ModKey Skyrim = ModKey.FromNameAndExtension("Skyrim.esm");
        private static Dictionary<string, FormKey> _mctKeywords = new();
        private static Dictionary<string, FormKey> _mctSpells = new();
        private static Lazy<Settings.Settings> _settings = null!;

        private static readonly (string, uint)[] GlobalIDs =
        {
            ("sprintToSneak", 0x289FB6),
            ("attackSpeedFix", 0x24747E),
            ("playerAttackControl", 0x24644D),
            ("powerAttackControl", 0x24644E),
            ("staggerByArrow", 0x2551A0),
            ("powerAttackCooldown", 0x2659C0),
            ("CGOIntegration", 0x28A519)
        };

/*private static readonly (string Key, uint Id)[] keywordsTuple =
        {
            ("MCT_ArmoredKW", 0x0028FF),
            ("MCT_WeakAgainstArmored", 0x0E3805),
            ("MCT_CanCritHigh", 0x0E3806),
            ("MCT_CanCritMed", 0x111124),
            ("MCT_CanCritLow", 0x111125),
            ("MCT_CritImmune", 0x111126
            "MCT_InjuryAttackSpeed", 0x13EA56
            "MCT_InjuryBleed", 0x13EA57
            "MCT_InjuryStun", 0x13EA58
            "MCT_InjuryKnockDown", 0x13EA59
            "MCT_InjuryMoveSpeed", 0x13EA5A
            "MCT_PowerAttackCoolDownKW", 0x22C9DC
            "MCT_StaggerImmune", 0x24A510
            "MCT_StaggerResist0", 0x2561C8
            "MCT_StaggerResist1", 0x2561C9
            "MCT_StaggerResist2", 0x2561CA
            "MCT_StaggerResist3", 0x2561CB
            "MCT_StaggerResist4", 0x2561CC
            "MCT_StaggerPower0", 0x25775B
            "MCT_StaggerPower1", 0x25775C
            "MCT_StaggerPower2", 0x25775D
            "MCT_StaggerPower3", 0x25775E
            "MCT_StaggerPower4", 0x25775F
            "MCT_SprintAttack", 0x26D5A1
            "MCT_NormalAttackRight", 0x26E067
            "MCT_NormalAttackLeft", 0x26E068
            "MCT_StompAttack", 0x2700B5
            "MCT_GiantRaceKW", 0x270618
            "MCT_StaminaControlledKW", 0x27210E
            "MCT_CanEnrage", 0x272675
            "MCT_InjuryEffect", 0x272BD9
            "MCT_DragonRaceKW", 0x273140
            "MCT_DragonTailAttackLeft", 0x27416B
            "MCT_DragonTailAttackRight", 0x27416D
            "MCT_DragonTailAttack", 0x27416E
             "MCT_BlockableSpell", 0x277748
             "MCT_PowerBlockingKW", 0x27DDB1
             "MCT_VerticalAttack", 0x2808D7
             "MCT_PenetratesArmorKW", 0x281901
             "MCT_WerewolfRaceKW", 0x28DB00
             "MCT_PaddedKW", 0x0028FD
             "MCT_DefensiveAttack", 0x2936A2
             "MCT_SweepAttack", 0x294169
        };*/

        #endregion

        #region Enums

        private enum WeaponCritChance
        {
            None = 0,
            Low = 1,
            Medium = 2,
            High = 3
        }

        private enum WeaponArmorPenetration
        {
            Weak = -1,
            None = 0,
            Strong = 1
        }

        #endregion

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out _settings)
                .Run(args, new RunPreferences()
                {
                    ActionsForEmptyArgs = new RunDefaultPatcher()
                    {
                        IdentifyingModKey = "MCTPatch.esp",
                        TargetRelease = GameRelease.SkyrimSE,
                    }
                });
        }

        #region Auxiliary Methods

        private static void ChangeGlobalShortValue(IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
            IGlobalGetter global, short value)
        {
            var globalCopy = (IGlobalShort) state.PatchMod.Globals.GetOrAddAsOverride(global);
            globalCopy.Data = value;
        }

        private static void AddKeyword(FormKey keywordForm, IKeyworded<IKeywordGetter> keyworded)
        {
            keyworded.Keywords ??= new ExtendedList<IFormLink<IKeywordGetter>>();
            keyworded.Keywords.Add(keywordForm);
        }

        private static void SetStagger(IWeapon weaponCopy, int defaultWeight, float multiplier)
        {
            float weight = weaponCopy.BasicStats!.Weight;
            if (weight <= 0)
            {
                weaponCopy.BasicStats!.Weight = defaultWeight;
            }

            weaponCopy.Data!.Stagger = weight * 0.01f * multiplier;
        }

        private static void ChangeWeapon(IWeapon weaponCopy, int defaultWeight, float damageMult = 1,
            float reachMult = 1, float speedMult = 1, float critMult = 1, float staggerMult = 1,
            WeaponCritChance critChance = WeaponCritChance.None,
            WeaponArmorPenetration armorPenetration = WeaponArmorPenetration.None)
        {
            string critKey = critChance switch
            {
                WeaponCritChance.Low => "MCT_CanCritLow",
                WeaponCritChance.Medium => "MCT_CanCritMed",
                WeaponCritChance.High => "MCT_CanCritHigh",
                _ => "None"
            };
            if (_mctKeywords.TryGetValue(critKey, out FormKey keyword))
            {
                AddKeyword(keyword, weaponCopy);
            }

            if (weaponCopy.Data!.Flags.HasFlag(WeaponData.Flag.BoundWeapon))
            {
                weaponCopy.BasicStats!.Weight = defaultWeight;
                if (_mctKeywords.TryGetValue("MCT_PenetratesArmorKW", out keyword))
                {
                    AddKeyword(keyword, weaponCopy);
                }
            }
            else
            {
                switch (armorPenetration)
                {
                    case WeaponArmorPenetration.Weak:
                        if (_mctKeywords.TryGetValue("MCT_WeakAgainstArmored", out keyword))
                        {
                            AddKeyword(keyword, weaponCopy);
                        }

                        break;
                    case WeaponArmorPenetration.Strong:
                        if (_mctKeywords.TryGetValue("MCT_PenetratesArmorKW", out keyword))
                        {
                            AddKeyword(keyword, weaponCopy);
                        }

                        break;
                }
            }

            weaponCopy.BasicStats!.Damage = (ushort) Math.Round(weaponCopy.BasicStats.Damage * damageMult);
            weaponCopy.Data.Speed *= speedMult;
            weaponCopy.Data.Reach *= reachMult;
            SetStagger(weaponCopy, defaultWeight, staggerMult);
            weaponCopy.Critical!.Damage = (ushort) Math.Round(weaponCopy.BasicStats!.Damage *
                                                              _settings.Value.weaponSettings.weaponCritDamageMult *
                                                              critMult);
        }

        private static ISpellGetter GetSpellFromId(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, uint id)
        {
            var spellForm = Engarde.MakeFormKey(id);
            if (!state.LinkCache.TryResolve<ISpellGetter>(spellForm, out ISpellGetter? spellGetter))
                throw new Exception($"Unable to find required spell: {spellForm}");
            return spellGetter;
        }

        private static bool IsValidAttack(IAttackGetter attack)
        {
            return attack.AttackData?.Stagger != null && !attack.AttackEvent.IsNullOrEmpty();
        }

        private static void ChangeBasicAttackStats(IAttack attack, int strikeAngle = -1,
            float strikeChance = float.NaN, float damageMult = 0, float attackAngle = float.NaN)
        {
            attack.AttackData!.DamageMult += damageMult;
            if (strikeAngle != -1)
            {
                attack.AttackData.StrikeAngle = strikeAngle;
            }

            if (!float.IsNaN(attackAngle))
            {
                attack.AttackData.AttackAngle = attackAngle;
            }

            if (!float.IsNaN(strikeChance))
            {
                attack.AttackData.Chance = strikeChance;
            }
        }

        private static void SetGeneralAttackData(IAttack attack)
        {
            if (!IsValidAttack(attack) || attack.AttackEvent!.Contains("H2H")) return;
            string attackEvent = attack.AttackEvent;
            attack.AttackData!.Knockdown = 0;
            if (attack.AttackData.Spell.IsNull)
            {
                if ((attackEvent.Contains("PowerStartLeft") || attackEvent.Contains("PowerStartRight")) &&
                    _settings.Value.basicAttacks.basicAttackTweaks)
                {
                    if (_mctSpells.TryGetValue("MCT_SidePowerAttackSpell", out FormKey spellKey))
                    {
                        attack.AttackData.Spell = spellKey;
                    }
                }
                else if ((attackEvent == "attackPowerStartBackward" || attackEvent == "attackPowerStartBackLeftHand") &&
                         _settings.Value.powerAttacks.powerAttackTweaks)
                {
                    if (_mctSpells.TryGetValue("MCT_BackPowerAttackSpell", out FormKey spellKey))
                    {
                        attack.AttackData.Spell = spellKey;
                    }
                }
                else if (attack.AttackData.Flags.HasFlag(AttackData.Flag.BashAttack) &&
                         _settings.Value.basicAttacks.basicAttackTweaks)
                {
                    if (attack.AttackData.Flags.HasFlag(AttackData.Flag.PowerAttack))
                    {
                        if (_mctSpells.TryGetValue("MCT_PowerBashAttackSpell", out FormKey spellKey))
                        {
                            attack.AttackData.Spell = spellKey;
                        }
                    }
                    else
                    {
                        if (_mctSpells.TryGetValue("MCT_BashAttackSpell", out FormKey spellKey))
                        {
                            attack.AttackData.Spell = spellKey;
                        }
                    }
                }
                else if (attack.AttackData.Flags.HasFlag(AttackData.Flag.PowerAttack) &&
                         _settings.Value.staggerSettings.weaponStagger)
                {
                    if (_mctSpells.TryGetValue("MCT_PowerAttackSpell", out FormKey spellKey))
                    {
                        attack.AttackData.Spell = spellKey;
                    }
                }
                else if (_settings.Value.staggerSettings.weaponStagger)
                {
                    if (_mctSpells.TryGetValue("MCT_PowerAttackSpell", out FormKey spellKey))
                    {
                        attack.AttackData.Spell = spellKey;
                    }
                }
            }

            if (attackEvent.Contains("Forward") || attackEvent.Contains("Lunge") || attackEvent.Contains("Bite"))
            {
                attack.AttackData.StrikeAngle = 28;
                if (_mctKeywords.TryGetValue("MCT_VerticalAttack", out FormKey keyword))
                {
                    attack.AttackData.AttackType = keyword;
                }
            }

            switch (attackEvent)
            {
                case "AttackStart_LeftChop":
                    ChangeBasicAttackStats(attack, 28, attackAngle: -35);
                    break;
                case "AttackStart_RightChop":
                    ChangeBasicAttackStats(attack, 28, attackAngle: 35);
                    break;
                case "attackPowerStartInPlace":
                case "attackPowerStartInPlaceLeftHand":
                    ChangeBasicAttackStats(attack, 28, 1);
                    break;
                case "attackPowerStartForward":
                case "attackPowerStartForwardLeftHand": //28 0.1f +0.5f
                    ChangeBasicAttackStats(attack, 28, 0.1f, 0.5f);
                    break;
                case "attackPowerStartBackward":
                    ChangeBasicAttackStats(attack, 65, 0);
                    attack.AttackData.Flags.SetFlag(AttackData.Flag.RotatingAttack, true);
                    break;
                case "attackPowerStartDualWield":
                {
                    ChangeBasicAttackStats(attack, 50, 1, -0.5f);
                    attack.AttackData.AttackType = Skyrim.MakeFormKey(0x0914E7);
                    if (_mctSpells.TryGetValue("MCT_DualPowerAttackSpell", out FormKey spellKey))
                    {
                        attack.AttackData.Spell = spellKey;
                    }

                    break;
                }
                case "attackStartDualWield":
                    ChangeBasicAttackStats(attack, 50, damageMult: -0.25f);
                    break;
                case "attackStart":
                {
                    ChangeBasicAttackStats(attack, 65);
                    if (_mctKeywords.TryGetValue("MCT_NormalAttackRight", out FormKey keyword))
                    {
                        attack.AttackData.AttackType = keyword;
                    }

                    break;
                }
                case "attackStartLeftHand":
                {
                    ChangeBasicAttackStats(attack, 50);
                    if (_mctKeywords.TryGetValue("MCT_NormalAttackLeft", out FormKey keyword))
                    {
                        attack.AttackData.AttackType = keyword;
                    }

                    break;
                }
                case "bashPowerStart":
                    ChangeBasicAttackStats(attack, 80);
                    break;
                default:
                {
                    if (attackEvent.Contains("PowerStartLeft") || attackEvent.Contains("PowerStartRight"))
                    {
                        ChangeBasicAttackStats(attack, 65, 0, -1);
                        attack.AttackData.Flags.SetFlag(AttackData.Flag.RotatingAttack, true);
                    }

                    else if (attackEvent.Contains("Chop"))
                    {
                        ChangeBasicAttackStats(attack, 25);
                        if (_mctKeywords.TryGetValue("MCT_VerticalAttack", out FormKey keyword))
                        {
                            attack.AttackData.AttackType = keyword;
                        }
                    }

                    else if (attackEvent.Contains("attack") && attackEvent.Contains("Start") &&
                             attackEvent.Contains("Sprint"))
                    {
                        ChangeBasicAttackStats(attack, 28, 2);
                        if (_mctKeywords.TryGetValue("MCT_SprintAttack", out FormKey keyword))
                        {
                            attack.AttackData.AttackType = keyword;
                        }
                    }

                    break;
                }
            }
        }

        private static void SetAtronachFrostAttackData(IAttack attack)
        {
            if (!IsValidAttack(attack))
            {
                return;
            }

            string attackEvent = attack.AttackEvent!;
            attack.AttackData!.Spell = _mctSpells["MCT_PowerAttackSpell"];
            switch (attackEvent)
            {
                case "attackPowerStart_ForwardPowerAttack_R1":
                    ChangeBasicAttackStats(attack, strikeAngle: 5);
                    attack.AttackData.AttackType = FormLink<IKeywordGetter>.Null;
                    break;
                case "attackPowerStart_PowerAttack_L1":
                    ChangeBasicAttackStats(attack, strikeChance: 0.7f, attackAngle: -15);
                    break;
                case "attackStart_Attack_L1":
                    ChangeBasicAttackStats(attack, strikeChance: 1, attackAngle: -25, damageMult: 0.5f);
                    attack.AttackData.Flags.SetFlag(AttackData.Flag.PowerAttack, true);
                    break;
                case "attackStart_Attack_R1":
                    ChangeBasicAttackStats(attack, strikeAngle:25, strikeChance:1,damageMult:0.5f, attackAngle:5);
                    attack.AttackData.Flags.SetFlag(AttackData.Flag.PowerAttack, true);
                    break;
                case "bashPowerStart":
                    ChangeBasicAttackStats(attack, strikeAngle:65);
                    break;
            }
        }

        #endregion

        #region Patcher Methods

        private static void PatchArmors(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            foreach (IArmorGetter? armor in state.LoadOrder.PriorityOrder.WinningOverrides<IArmorGetter>())
            {
                if ((armor.BodyTemplate?.Flags.HasFlag(BodyTemplate.Flag.NonPlayable) ?? true)
                    || !armor.TemplateArmor.IsNull
                    || (!armor.BodyTemplate?.FirstPersonFlags.HasFlag(BipedObjectFlag.Body) ?? true))
                {
                    continue;
                }

                switch (armor.BodyTemplate!.ArmorType)
                {
                    case ArmorType.LightArmor:
                    {
                        Armor armorCopy = state.PatchMod.Armors.GetOrAddAsOverride(armor);
                        armorCopy.Keywords ??= new ExtendedList<IFormLink<IKeywordGetter>>();
                        _mctKeywords.TryGetValue("MCT_StaggerResist1", out FormKey staggerResistKeyword);
                        armorCopy.Keywords.Add(staggerResistKeyword);
                        break;
                    }
                    case ArmorType.HeavyArmor:
                    {
                        Armor armorCopy = state.PatchMod.Armors.GetOrAddAsOverride(armor);
                        armorCopy.Keywords ??= new ExtendedList<IFormLink<IKeywordGetter>>();
                        _mctKeywords.TryGetValue("MCT_StaggerResist2", out FormKey staggerResistKeyword);
                        _mctKeywords.TryGetValue("MCT_ArmoredKW", out FormKey armoredKeyword);
                        armorCopy.Keywords.Add(staggerResistKeyword);
                        armorCopy.Keywords.Add(armoredKeyword);
                        break;
                    }
                    default: continue;
                }
            }
        }

        private static void PatchGlobals(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Dictionary<string, IGlobalGetter> globals = new();

            foreach ((string, uint) globalId in GlobalIDs)
            {
                var globalForm = Engarde.MakeFormKey(globalId.Item2);
                if (!state.LinkCache.TryResolve<IGlobalGetter>(globalForm, out var globalLink))
                    throw new Exception($"Unable to find required global: {globalForm}");
                globals.Add(globalLink.EditorID!, globalLink);
            }

            if (globals.TryGetValue("MCT_SprintToSneakEnabled", out var global))
            {
                ChangeGlobalShortValue(state, global, _settings.Value.sprintToSneak ? 1 : 0);
            }

            if (globals.TryGetValue("MCT_AttackSpeedFixEnabled", out global))
            {
                ChangeGlobalShortValue(state, global, _settings.Value.fixAttackSpeed ? 1 : 0);
            }

            if (globals.TryGetValue("MCT_PlayerAttackControlEnabled", out global))
            {
                ChangeGlobalShortValue(state, global, _settings.Value.basicAttacks.basicAttackTweaks ? 1 : 0);
            }

            if (globals.TryGetValue("MCT_PowerAttackControlEnabled", out global))
            {
                ChangeGlobalShortValue(state, global, _settings.Value.powerAttacks.powerAttackTweaks ? 1 : 0);
            }

            if (globals.TryGetValue("MCT_StaggerByArrowEnabled", out global))
            {
                ChangeGlobalShortValue(state, global,
                    _settings.Value.staggerSettings.bowStagger ? (short) 1 : (short) 0);
            }

            if (globals.TryGetValue("MCT_PowerAttackCoolDownTime", out global))
            {
                ChangeGlobalShortValue(state, global, _settings.Value.powerAttacks.powerAttackCooldown);
            }

            if (globals.TryGetValue("MCT_CGOIntegrationEnabled", out global))
            {
                ChangeGlobalShortValue(state, global, state.LoadOrder.TryGetIfEnabled(
                    ModKey.FromNameAndExtension("DSerCombatGameplayOverhaul.esp"), out _)
                    ? 1
                    : 0);
            }
        }

        private static void PatchWeapons(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            ModKey masterKey = ModKey.FromNameAndExtension("Skyrim.esm");
            SkyrimMod master = new SkyrimMod(masterKey, SkyrimRelease.SkyrimSE);
            Keyword battleaxeKeyword = new Keyword(master, "WeapTypeBattleaxe");
            Keyword warhammerKeyword = new Keyword(master, "WeapTypeWarhammer");
            if (!state.LinkCache.TryResolve<ISpellGetter>(Engarde.MakeFormKey(0x23BCE7), out var critAttackSpell))
            {
                throw new Exception($"Crit Attack spell ID:xx23BCE7 not found, check your Engarde.esp");
            }

            foreach (IWeaponGetter weapon in state.LoadOrder.PriorityOrder.WinningOverrides<IWeaponGetter>())
            {
                if (!weapon.Template.IsNull || weapon.Data == null)
                {
                    continue;
                }

                Weapon weaponCopy = state.PatchMod.Weapons.GetOrAddAsOverride(weapon);
                weaponCopy.Data!.Speed *= _settings.Value.weaponSettings.weaponSpeedMult;
                weaponCopy.Data!.Reach *= _settings.Value.weaponSettings.weaponReachMult;
                ushort damage = weaponCopy.BasicStats!.Damage;
                weaponCopy.BasicStats!.Damage =
                    (ushort) Math.Round(damage * _settings.Value.weaponSettings.weaponDamageMult);
                if (weaponCopy.BasicStats.Weight == 0)
                {
                    weaponCopy.BasicStats.Weight = 4;
                }

                if (_settings.Value.staggerSettings.critStagger && (weaponCopy.Critical?.Effect.IsNull ?? false))
                {
                    weaponCopy.Critical.Effect = critAttackSpell.AsLink();
                    weaponCopy.Critical.Flags = 0;
                }

                switch (weaponCopy.Data.AnimationType)
                {
                    case WeaponAnimationType.HandToHand:
                    {
                        if (weaponCopy.Data.Flags.HasFlag(WeaponData.Flag.BoundWeapon))
                        {
                            weaponCopy.BasicStats.Weight = 2;
                            if (_mctKeywords.TryGetValue("MCT_PenetratesArmorKW", out var keyword))
                            {
                                AddKeyword(keyword, weaponCopy);
                            }
                        }

                        if (weaponCopy.EditorID == "HRI_Lycan_Weapon_UnarmedWereformWeapon")
                        {
                            weaponCopy.BasicStats.Weight = 4;
                            if (_mctKeywords.TryGetValue("MCT_WeakAgainstArmored", out var keyword))
                            {
                                AddKeyword(keyword, weaponCopy);
                            }
                        }

                        break;
                    }
                    case WeaponAnimationType.OneHandSword:
                        ChangeWeapon(weaponCopy, 8, reachMult: 1.15f, staggerMult: 0.85f,
                            critChance: WeaponCritChance.Medium, armorPenetration: WeaponArmorPenetration.Weak);
                        break;
                    case WeaponAnimationType.OneHandDagger:
                        ChangeWeapon(weaponCopy, 3, critMult: 2, critChance: WeaponCritChance.High,
                            armorPenetration: WeaponArmorPenetration.Weak);
                        break;
                    case WeaponAnimationType.OneHandAxe:
                        ChangeWeapon(weaponCopy, 10, 1.1f, 0.8f, 1.1f);
                        break;
                    case WeaponAnimationType.OneHandMace:
                        ChangeWeapon(weaponCopy, 12, critMult: 0.5f);
                        break;
                    case WeaponAnimationType.TwoHandSword:
                        ChangeWeapon(weaponCopy, 14, 0.9f, 1.15f, staggerMult: 1.35f, critChance: WeaponCritChance.Low,
                            armorPenetration: WeaponArmorPenetration.Weak);
                        break;
                    case WeaponAnimationType.TwoHandAxe when weaponCopy.Keywords?.Contains(warhammerKeyword) ?? false:
                        ChangeWeapon(weaponCopy, 18, 0.9f, speedMult: 0.9f, critMult: 0.5f, staggerMult: 1.65f,
                            armorPenetration: WeaponArmorPenetration.Strong);
                        break;
                    case WeaponAnimationType.TwoHandAxe when weaponCopy.Keywords?.Contains(battleaxeKeyword) ?? false:
                    {
                        ChangeWeapon(weaponCopy, 16, reachMult: 0.8f, speedMult: 1.1f, staggerMult: 1.5f);
                        break;
                    }
                    case WeaponAnimationType.Crossbow:
                    case WeaponAnimationType.Bow when weaponCopy.EditorID?.ToLower().Contains("crossbow") ?? false:
                        ChangeWeapon(weaponCopy, 12, critMult: 2, staggerMult: 1.5f,
                            armorPenetration: WeaponArmorPenetration.Strong);
                        break;
                    case WeaponAnimationType.Bow:
                        ChangeWeapon(weaponCopy, 8, armorPenetration: WeaponArmorPenetration.Weak);
                        break;
                    case WeaponAnimationType.Staff:
                        ChangeWeapon(weaponCopy, 8, reachMult: 1.15f, critMult: 0.5f,
                            armorPenetration: WeaponArmorPenetration.Weak);
                        break;
                }
            }
        }

        private static void PatchRaces(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            foreach (IRaceGetter race in state.LoadOrder.PriorityOrder.WinningOverrides<IRaceGetter>())
            {
                Race raceCopy = state.PatchMod.Races.GetOrAddAsOverride(race);
                string behavior = raceCopy.BehaviorGraph.Male?.File ?? raceCopy.BehaviorGraph.Female?.File ?? "";
                raceCopy.AngularAccelerationRate = _settings.Value.npcSettings.angularAccelerationMult * 0.25f;
                raceCopy.UnarmedReach = _settings.Value.npcSettings.unarmedReachMult * 96;
                raceCopy.UnarmedDamage *= _settings.Value.npcSettings.unarmedDamageMult;

                raceCopy.ActorEffect ??= new ExtendedList<IFormLink<IASpellGetter>>();
                if (_settings.Value.fixAttackSpeed &&
                    _mctSpells.TryGetValue("MCT_BaseWeaponSpeedMultSpell", out FormKey baseAttackSpeedSpell))
                {
                    raceCopy.ActorEffect.Add(baseAttackSpeedSpell);
                }

                if (_settings.Value.staggerSettings.bowStagger &&
                    _mctSpells.TryGetValue("MCT_DefaultRaceSpell", out FormKey defaultRaceSpell))
                {
                    raceCopy.ActorEffect.Add(defaultRaceSpell);
                }

                if (raceCopy.EditorID != "WerewolfBeastRace")
                {
                    raceCopy.Attacks.ForEach(SetGeneralAttackData);
                }

                if (raceCopy.HasKeyword("ActorTypeNPC", state.LinkCache))
                {
                    raceCopy.Keywords!.Add(_mctKeywords["MCT_StaggerResist1"]);
                    raceCopy.Keywords.Add(_mctKeywords["MCT_InjuryAttackSpeed"]);
                    raceCopy.ActorEffect ??= new ExtendedList<IFormLink<IASpellGetter>>();
                    raceCopy.ActorEffect.Add(_mctSpells["MCT_DefaultRaceSpell"]);
                }

                if (raceCopy.HasKeyword("ActorTypeUndead", state.LinkCache))
                {
                    raceCopy.Keywords!.Add(_mctKeywords["MCT_CritImmune"]);
                }

                if (behavior == "Actors\\AtronachFrost\\AtronachFrostProject.hkx")
                {
                    raceCopy.ActorEffect.Remove(_mctSpells["MCT_DefaultRaceSpell"]);
                    raceCopy.Keywords ??= new ExtendedList<IFormLink<IKeywordGetter>>();
                    raceCopy.Keywords.Add(_mctKeywords["MCT_ArmoredKW"]);
                    if (_settings.Value.npcSettings.addArmorToArmored)
                    {
                        raceCopy.ActorEffect.Add(_mctKeywords["MCT_BonusArmor500"]);
                    }

                    raceCopy.AngularAccelerationRate = 0.75f * _settings.Value.npcSettings.angularAccelerationMult;
                    raceCopy.UnarmedReach = 196 * _settings.Value.npcSettings.unarmedReachMult;
                    raceCopy.Attacks.ForEach(SetAtronachFrostAttackData);
                }
            }
        }

        #endregion

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if (state.LoadOrder.TryGetIfEnabled(Engarde, out var listing))
            {
                _mctKeywords = listing.Mod!.Keywords.ToDictionary(x => x.EditorID!, x => x.FormKey);
                _mctSpells = listing.Mod!.Spells.ToDictionary(x => x.EditorID!, x => x.FormKey);
            }
            else
            {
                throw new Exception("Engarde.esp not active in your load order or doesn`t exist!");
            }

            PatchGlobals(state);
            PatchArmors(state);
            PatchWeapons(state);

            PatchRaces(state);
        }
    }
}